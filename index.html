<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VDA Group Project 3</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
</head>

<body>
    <div id="tooltip"
        style="position: absolute; visibility: hidden; padding: 10px; background-color: white; border: 1px solid black;">
    </div>

    <div class="title-container">
        <img src="https://logodownload.org/wp-content/uploads/2016/11/formula-1-logo-5-3.png" class="title-icon">
        <h2>F1 Race Map and Driver Rank from 1950 to 2023</h2>
    </div>

    <div class="selector">
        <p>Select the year, then click on the races to see driver ranks for the circuit you selected.</p>
    <select id="yearSelector" class="select-style"></select>
        <!-- Options will be added dynamically --> 
    </div>

    <svg id="graph" height="800" width="1000">
        <text id="label" x="590" y="5" text-anchor="end" alignment-baseline="hanging"></text>
    </svg>

    <div class="footer">
        <p>Created by Jinmo Huang, Sonia Sunil, Bandar Qadan, Kellan Liu</p>
    </div>

    <script>
        const svg = d3.select("#graph");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const mapWidth = width - margin.left - margin.right;
        const mapHeight = height - margin.top - margin.bottom;

        let selectedCircle = null; 

        const requestData = async () => {
            const circuits = await d3.csv('./data/circuits.csv');
            const races = await d3.csv('./data/races.csv');
            const drivers = await d3.csv('./data/drivers.csv');
            const race_results = await d3.csv('./data/results.csv');
            const lap_times = await d3.csv('./data/lap_times.csv');
            let worldMap = await d3.json('./data/World_Map.geojson');

            console.log(worldMap);

            let newData = races.map(item => {
                return {
                    ...item,
                    ...circuits.find(innerItem => innerItem.circuitId === item.circuitId)
                }
            });

            let racerData = [];
            racerData = race_results.map(item => {
                return {
                    ...item,
                    ...drivers.find(innerItem => innerItem.driverId === item.driverId)
                }
            });

            let grouped_results = new Map();
            racerData.forEach(item => {
                const key = item.raceId;
                const collection = grouped_results.get(key);

                if (!collection) {
                    grouped_results.set(key, [item]);
                } else {
                    collection.push(item);
                }
            });

            let grouped = Object.fromEntries(grouped_results);


            let data = newData.map(item => {
                return {
                    ...item,
                    raceId: grouped[item.raceId]
                }
            });

            nonfinal_data = [];
            data = data.forEach((obj, index) => {
                if (obj.raceId !== undefined) {
                    let race_result = obj.raceId;
                    let updated_result = []
                    race_result.forEach(race => {

                        if (race.rank !== "0") {
                            updated_result.push(race);
                        }
                    })

                    obj.raceId = updated_result;
                    nonfinal_data.push(obj);

                }
            });


            nonfinal_data.forEach((data, i) => {
                data.lat = +data.lat;
                data.lng = +data.lng;
                data.raceId.forEach((d) => {
                    d.positionOrder = +d.positionOrder;
                })
            });
            console.log("final_data", nonfinal_data);
            let final_data = [...nonfinal_data];
            worldMap = {
                ...worldMap,
                features: worldMap.features.filter(feature => feature.properties.name !== 'Antarctica')
            };

            let projection = d3.geoMercator()
                .fitSize([mapWidth, mapHeight], worldMap);

            let path = d3.geoPath().projection(projection);

            let geoMap = null;

            if (!geoMap) {
                geoMap = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
            }
            geoMap.selectAll('path')
                .data(worldMap.features)
                .join('path')
                .attr('class', 'path')
                .attr('d', path)
                .attr('fill', 'white')
                .attr('stroke', '#868686');

            final_data.forEach(d => {
                d.Position = projection([d.lng, d.lat]);
            });

            let circle_Data = [];

            let uniqueYears = [...new Set(final_data.map(race => race.year))];
            const yearSelector = d3.select("#yearSelector");
            uniqueYears.forEach(year => {
                yearSelector.append("option")
                    .text(year)
                    .attr("value", year);
            });

            yearSelector.on("change", function (event) {
                    const selectedYear = event.target.value;
                    updateVisualization(selectedYear);
                    svg.select('.racers').selectAll('g').remove();
                    d3.select('#label').text('');
                });

            function updateVisualization(year) {
                if (selectedCircle) {
                    selectedCircle.attr('stroke', 'transparent');
                    d3.select('#label').text('');
                    selectedCircle = null;
                }

                final_data = [];
                nonfinal_data.forEach(item => {
                    if (item.year === year) {
                        final_data.push(item)
                    }
                })
                geoMap.selectAll("circle")
                    .data(final_data)
                    .join("circle")
                    .attr("r", 8)
                    .attr("fill", '#EE0000')
                    .attr("opacity", 0.8)
                    .attr("cx", d => d.Position[0])
                    .attr("cy", d => d.Position[1])
                    .on("mouseover", function (event, d) {
                        if (this !== selectedCircle?.node()) {
                            d3.select(this).transition()
                                .duration(100)
                                .attr('stroke-width', 3.5)
                                .attr('stroke', 'black');
                        }
                        let title = d3.select(this).datum()['name'];
                        let location = d3.select(this).datum()['location'];
                        let country = d3.select(this).datum()['country'];
                        d3.select('#label')
                            .text(country + ", " + location + ": " + title);
                    })
                    .on("mouseout", function () {
                        if (this !== selectedCircle?.node()) {
                            d3.select(this).transition()
                                .duration(100)
                                .attr('stroke', 'transparent');
                            d3.select('#label').text('');
                        }
                    })
                    .on("click", function (event, d) {
                        if (selectedCircle) {
                            selectedCircle.attr('stroke', 'transparent');
                        }
                        selectedCircle = d3.select(this);
                        selectedCircle.transition()
                            .duration(100)
                            .attr('stroke-width', 3.5)
                            .attr('stroke', 'black');
                        let title = d['name'];
                        let location = d['location'];
                        let country = d['country'];
                        d3.select('#label').text(country + ", " + location + ": " + title);
                        circle_Data = d['raceId'];
                        load_race(circle_Data);
                    })

                svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")").attr("class", "racers");

                function load_race(data) {
                svg.select('.racers').selectAll('g').remove();
                console.log("data", data)

                const extent = d3.extent(data, d => d.positionOrder);
                const xScale = d3.scaleLinear()
                                 .domain(extent) // Data space
                                 .range([20, mapWidth - 50]); // Screen space

                const groups = svg.select('.racers').selectAll('g')
                    .data(data)
                    .enter()
                    .append('g')
                    .attr('transform', d => `translate(${xScale(d.positionOrder)}, 50)`) // 设置组的位置
                    .on("mouseover", function (event, d) {
                        showTooltip(event, d);
                        d3.select(this).select('circle').transition()
                            .duration(100)
                            .attr('stroke', 'red');
                        d3.select(this).select('text').transition()
                            .duration(100)
                            .attr('fill', 'red');
                    })
                    .on("mouseout", function () {
                        d3.select("#tooltip").style("visibility", "hidden");
                        d3.select(this).select('circle').transition()
                            .duration(100)
                            .attr('stroke', 'transparent');
                        d3.select(this).select('text').transition()
                            .duration(100)
                            .attr('fill', 'black');
                });

                groups.append('circle')
                      .attr('r', 15) 
                      .attr('fill', 'white');

                groups.append('text')
                      .attr('y', 5) 
                      .attr('text-anchor', 'middle')
                      .text(d => `${d.positionOrder}`);

                function showTooltip(event, d) {
                    const newContent = `Last Name: ${d.surname}<br>` +
                        `First Name: ${d.forename}<br>` +
                        `Rank: ${d.positionOrder}<br>` +
                        `Nationality: ${d.nationality}`;

                    d3.select("#tooltip")
                        .style("visibility", "visible")
                        .html(newContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                }
                group.exit().remove();
            }
                }
                            const initialYear = uniqueYears[0]; 
                            updateVisualization(initialYear)
                        }
                                        

                    requestData();
                    
                    

    </script>
</body>

</html>

<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        min-height: 100vh;
        background: #EFEFEF;
}

    .title-container {
        text-align: center;
    }

    .title-icon {
        width: 200px; 
        height: auto; 
        margin: 10px; 
}
    .selector{
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
    }
    .select-style {
        padding: 10px 15px;
        border: 1px solid #ccc;
        border-radius: 20px; 
        background-color: white;
        background-repeat: no-repeat;
        background-position: right 10px center;
        -webkit-appearance: none; 
        -moz-appearance: none; 
        appearance: none; 
        font-size: 16px; 
        color: #333; 
        margin-top: 20px; 
    }

    #tooltip {
        position: absolute;
        visibility: hidden;
        padding: 10px;
        background-color: white;
        border: none;
        text-align: center; 
}
    .footer {
        text-align: center;
        margin-top: 50px;
        padding: 20px;
        color: #333;
        font-size: 14px;
    }
    
    p{
        color: #333;
    }
</style>